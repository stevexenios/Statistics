help(t.test)
t.test(data.df$Net.worth[data.df$Industry == "Diversified"], alternative ="two.sided", mu = divMean)
t.test(data.df$Net.worth[data.df$Industry == "Technology"], alternative ="two.sided", mu = techMean)
t.test(data.df$Net.worth[data.df$Industry == "Diversified"],
data.df$Net.worth[data.df$Industry == "Technology"],
alternative ="two.sided",
paired = TRUE,
mu = c(divMean, techMean))
t.test(data.df$Net.worth[data.df$Industry == "Diversified"],
data.df$Net.worth[data.df$Industry == "Technology"],
alternative ="two.sided",
paired = TRUE,
mu = divMean-techMean)
lowerT = qt(0.25, df)
lowerT
upperT = qt(0.975, df)
upperT
lowerT = qt(0.25, df)
lowerT
upperT = qt(0.95, df)
upperT
# November 24, 2019
###################################################################################################
#OBJECTIVES:
#1. Estimation in R
###################################################################################################
#C1.
#Submitted R Script.
#--------------------------------------------------------------------------------------------------
#C2.
#Clean environment setup
rm(list=ls())
setwd("C:/Users/steve/Desktop/UWT/Fall Classes/TMATH 390/R Documents/R Assignments/R_Lab_9")
data.df =read.csv("data.csv")
#Qualitative: Industry(Levels: Diversified & Technology)
#Quantitative: Net Worth
#--------------------------------------------------------------------------------------------------
#C3.(2) Calculate a 95% confidence interval for the difference in population
# Copy and paste the function lines into the R console and execute
# This creates your own function to calculate Welch's corrected df.
welch.fn=function(s1,s2,n1,n2)
{
return(floor((s1^2/n1+s2^2/n2)^2/((s1^2/n1)^2/(n1-1)+(s2^2/n2)^2/(n2-1))))
}
# Next you would assign the object s1 the value for the
# sample standard deviation for your first sample,
# s2 the value for the sample standard deviation for your
# second sample, and n1 and n2 the sample sizes for your first
# and second sample.
#Quantitative Mean of Networth
qMean = round(mean(data.df$Net.worth), 4)
#Diversified measures of center
divMean = round(mean(data.df$Net.worth[data.df$Industry == "Diversified"]), 4)
round(median(data.df$Net.worth[data.df$Industry == "Diversified"]), 4)
divSd = round(sd(data.df$Net.worth[data.df$Industry == "Diversified"]), 4)
#Technology Measures of center
techMean = round(mean(data.df$Net.worth[data.df$Industry == "Technology"]), 4)
round(median(data.df$Net.worth[data.df$Industry == "Technology"]), 4)
techSd = round(sd(data.df$Net.worth[data.df$Industry == "Technology"]), 4)
#size of samples
divN = length(data.df$Net.worth[data.df$Industry == "Diversified"])
techN = length(data.df$Net.worth[data.df$Industry == "Technology"])
# And here is how your run the function:
#welch.fn(s1,s2,n1,n2)
df = welch.fn(divSd,techSd,divN,techN)
help(t.test)
t.test(data.df$Net.worth[data.df$Industry == "Diversified"], alternative ="two.sided", mu = divMean)
t.test(data.df$Net.worth[data.df$Industry == "Technology"], alternative ="two.sided", mu = techMean)
lowerT = qt(0.025, df)
lowerT
upperT = qt(0.975, df)
upperT
# Degrees of Freedom
df
#size of samples
divN
techN
diffSd = sqrt((divSd*divSd/divN)+(techSd*techSd/techN))
# Confidence Interval
lowerLimit = techMean-divMean - upperT*diffSd
upperLimit = techMean-divMean + upperT*diffSd
lowerLimit
upperLimit
# Degrees Of Freedom
df
help(t.test)
t.test(data.df$Net.worth[data.df$Industry == "Diversified"], alternative ="two.sided", mu = divMean)
t.test(data.df$Net.worth[data.df$Industry == "Technology"], alternative ="two.sided", mu = techMean)
t.test(data.df$Net.worth[data.df$Industry == "Technology"]-data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
mu = techMean - divMean)
prop.test(data.df$Net.worth[data.df$Industry == "Technology"]-data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
mu = techMean - divMean)
# Degrees Of Freedom
df
prop.test(data.df$Net.worth[data.df$Industry == "Technology"]-data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
conf.level = .95)
help(t.test)
#Pooled Variance is used when var.equal = TRUE, otherwise welchs
t.test(data.df$Net.worth[data.df$Industry == "Technology"]-data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
subset(1,14),
var.equal = TRUE,
mu = techMean - divMean)
#Pooled Variance is used when var.equal = TRUE, otherwise welchs
techData = subset(data.df$Net.worth[data.df$Industry == "Technology"], 1:14)
#Pooled Variance is used when var.equal = TRUE, otherwise welchs
techData = data.df$Net.worth[data.df$Industry == "Technology"](1:14)
#Pooled Variance is used when var.equal = TRUE, otherwise welchs
t.test(subdata.df$Net.worth[data.df$Industry == "Technology"], data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
var.equal = TRUE,
mu = techMean - divMean)
#Pooled Variance is used when var.equal = TRUE, otherwise welchs
t.test(data.df$Net.worth[data.df$Industry == "Technology"], data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
var.equal = TRUE,
mu = techMean - divMean)
#--------------------------------------------------------------------------------------------------
#INFERENCE IMBALANCE DESIGN
#C4 (3) You want to test whether the population mean of your quantitative...
#Pooled Variance is used when var.equal = TRUE, otherwise welchs
techMean
divMean
t.test(data.df$Net.worth[data.df$Industry == "Technology"], data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
var.equal = TRUE,
mu = techMean - divMean)
#Pooled Variance is used when var.equal = TRUE, otherwise welchs
t.test(data.df$Net.worth[data.df$Industry == "Technology"], data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
var.equal = FALSE,
mu = techMean - divMean)
#--------------------------------------------------------------------------------------------------
#INFERENCE IMBALANCE DESIGN
#C4 (3) You want to test whether the population mean of your quantitative...
#Pooled Variance is used when var.equal = TRUE, otherwise welchs
?prop.test
?t.test
#--------------------------------------------------------------------------------------------------
#INFERENCE IMBALANCE DESIGN
#C4 (3) You want to test whether the population mean of your quantitative...
#Pooled Variance is used when var.equal = TRUE, otherwise welchs
?prop.test
techMean
divMean
t.test(data.df$Net.worth[data.df$Industry == "Technology"], data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
var.equal = TRUE,
mu = techMean - divMean)
#var.equal = FALSE, welchs
# Two independent samples with unequal variances
t.test(data.df$Net.worth[data.df$Industry == "Technology"], data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
var.equal = FALSE,
mu = techMean - divMean)
#--------------------------------------------------------------------------------------------------
#INFERENCE IMBALANCE DESIGN
#C4 (3) You want to test whether the population mean of your quantitative...
#Pooled Variance is used when var.equal = TRUE, otherwise welchs
?prop.test
techMean
divMean
t.test(data.df$Net.worth[data.df$Industry == "Technology"], data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
var.equal = TRUE,
mu = 0)
#var.equal = FALSE, welchs
# Two independent samples with unequal variances
t.test(data.df$Net.worth[data.df$Industry == "Technology"], data.df$Net.worth[data.df$Industry == "Diversified"],
alternative ="two.sided",
var.equal = FALSE,
mu = 0)
#--------------------------------------------------------------------------------------------------
#C5 (2) Conduct the t-test...
#Done
#--------------------------------------------------------------------------------------------------
#C6 (3) Describe any possible limitations there are...
#Done
#--------------------------------------------------------------------------------------------------
#C7 (4) Use full sentences to interpret the results of your analysis...
#T-test version using tdf and tobs...
?qt()
#--------------------------------------------------------------------------------------------------
#C5 (2) Conduct the t-test...
#Done
#--------------------------------------------------------------------------------------------------
#C6 (3) Describe any possible limitations there are...
#Done
#--------------------------------------------------------------------------------------------------
#C7 (4) Use full sentences to interpret the results of your analysis...
#T-test version using tdf and tobs...
qt(0.975, df)
#--------------------------------------------------------------------------------------------------
#C5 (2) Conduct the t-test...
#Done
#--------------------------------------------------------------------------------------------------
#C6 (3) Describe any possible limitations there are...
#Done
#--------------------------------------------------------------------------------------------------
#C7 (4) Use full sentences to interpret the results of your analysis...
#T-test version using tdf and tobs...
#t-value
Tdf = Fqt(0.975, df)
Tdf
#--------------------------------------------------------------------------------------------------
#C5 (2) Conduct the t-test...
#Done
#--------------------------------------------------------------------------------------------------
#C6 (3) Describe any possible limitations there are...
#Done
#--------------------------------------------------------------------------------------------------
#C7 (4) Use full sentences to interpret the results of your analysis...
#T-test version using tdf and tobs...
#t-value
Tdf = qt(0.975, df)
Tdf
# differences between the means
difference = techMean - divMean
difference
#Assuming equal Variances
sp_squared = ((techN-1)*techSd*techSd+(divN-1)*divSd*divSd)/(techN+divN-2)
Tobs_EqualVar = difference/sqrt(sp_squared((1/techN)+(1/divN)))
#Assuming equal Variances
spSquared = ((techN-1)*techSd*techSd+(divN-1)*divSd*divSd)/(techN+divN-2)
Tobs_EqualVar = difference/sqrt(sp_squared((1/techN)+(1/divN)))
#Assuming equal Variances
spSquared = ((techN-1)*techSd*techSd+(divN-1)*divSd*divSd)/(techN+divN-2)
Tobs_EqualVar = difference/sqrt(spSquared((1/techN)+(1/divN)))
#Assuming equal Variances
spSquared = ((techN-1)*techSd*techSd+(divN-1)*divSd*divSd)/(techN+divN-2)
Tobs_EqualVar = difference/sqrt(spSquared*((1/techN)+(1/divN)))
Tobs_EqualVar
#Unequal Variances
Tobs_UnEqualVar = difference/((techSd*techSd/techN)+(divSd*divSd/divN))
Tobs_UnEqualVar
#Reject Null if Tobs >= Tdf
Tdf >= Tobs_EqualVar
Tdf >= Tobs_UnEqualVar
#Equal Variances
2*pt(Tdf, techN+divN-2)-2*pt(Tobs_EqualVar,techN+divN-2)
2*pt(Tdf, df)-2*pt(Tobs_UnEqualVar,techN+divN-2)
#Equal Variances
2*pt(Tdf, techN+divN-2)-2*pt(Tobs_EqualVar,techN+divN-2)
2*pt(Tdf, df)-2*pt(Tobs_UnEqualVar,df)
#--------------------------------------------------------------------------------------------------
#C5 (2) Conduct the t-test...
#Done
#--------------------------------------------------------------------------------------------------
#C6 (3) Describe any possible limitations there are...
#Done
#--------------------------------------------------------------------------------------------------
#C7 (4) Use full sentences to interpret the results of your analysis...
#T-test version using tdf and tobs...
#t-value
Tdf = qt(0.975, df)
Tdf
# differences between the means
difference = techMean - divMean
difference
#Assuming equal Variances
spSquared = ((techN-1)*techSd*techSd+(divN-1)*divSd*divSd)/(techN+divN-2)
Tobs_EqualVar = difference/sqrt(spSquared*((1/techN)+(1/divN)))
Tobs_EqualVar
#Unequal Variances
Tobs_UnEqualVar = difference/((techSd*techSd/techN)+(divSd*divSd/divN))
Tobs_UnEqualVar
#Reject Null if Tobs >= Tdf
Tdf >= Tobs_EqualVar
Tdf >= Tobs_UnEqualVar
#Equal Variances
2*pt(Tdf, techN+divN-2)-2*pt(Tobs_EqualVar,techN+divN-2)
2*pt(Tdf, df)-2*pt(Tobs_UnEqualVar,df)
#--------------------------------------------------------------------------------------------------
#C5 (2) Conduct the t-test...
#Done
#--------------------------------------------------------------------------------------------------
#C6 (3) Describe any possible limitations there are...
#Done
#--------------------------------------------------------------------------------------------------
#C7 (4) Use full sentences to interpret the results of your analysis...
#T-test version using tdf and tobs...
#t-value
Tdf = qt(0.975, df)
Tdf
# differences between the means
difference = techMean - divMean
difference
#Assuming equal Variances
spSquared = ((techN-1)*techSd*techSd+(divN-1)*divSd*divSd)/(techN+divN-2)
Tobs_EqualVar = difference/sqrt(spSquared*((1/techN)+(1/divN)))
Tobs_EqualVar
#Unequal Variances
Tobs_UnEqualVar = difference/((techSd*techSd/techN)+(divSd*divSd/divN))
Tobs_UnEqualVar
#Reject Null if Tobs >= Tdf
Tdf <= Tobs_EqualVar
Tdf <= Tobs_UnEqualVar
#Equal Variances
2*pt(Tdf, techN+divN-2)-2*pt(Tobs_EqualVar,techN+divN-2)
2*pt(Tdf, df)-2*pt(Tobs_UnEqualVar,df)
#Reject Null if Tobs >= Tdf
Tdf <= Tobs_EqualVar
Tdf <= Tobs_UnEqualVar
#Equal Variances
2*pt(Tdf, techN+divN-2)>=2*pt(Tobs_EqualVar,techN+divN-2)
2*pt(Tdf, df)>=2*pt(Tobs_UnEqualVar,df)
#Qualitative: Industry(Levels: Diversified & Technology)
#Quantitative: Net Worth
#--------------------------------------------------------------------------------------------------
#C3.(2) Calculate a 95% confidence interval for the difference in population
# Copy and paste the function lines into the R console and execute
# This creates your own function to calculate Welch's corrected df.
welch.fn=function(s1,s2,n1,n2)
{
return(floor((s1^2/n1+s2^2/n2)^2/((s1^2/n1)^2/(n1-1)+(s2^2/n2)^2/(n2-1))))
}
dff = welch.fn(0.0005043,0.0004332,13,13)
dff
#Qualitative: Industry(Levels: Diversified & Technology)
#Quantitative: Net Worth
#--------------------------------------------------------------------------------------------------
#C3.(2) Calculate a 95% confidence interval for the difference in population
# Copy and paste the function lines into the R console and execute
# This creates your own function to calculate Welch's corrected df.
welch.fn=function(s1,s2,n1,n2)
{
return(floor((s1^2/n1+s2^2/n2)^2/((s1^2/n1)^2/(n1-1)+(s2^2/n2)^2/(n2-1))))
}
dff = welch.fn(19.15,15.37,15,18)
dff
# now we create the scatterplot. xlab gives the label for the x-axis,
# ylab the label for the y-axis. Make sure to update these with your own
# variables. pch gives the point type (16=solid points)
# see ?points for options. col gives the color for the points (?colors)
?points
###################################################################################################
#C1.
#Submitted R Script.
#--------------------------------------------------------------------------------------------------
# C6.
# Part 2: Linear regression on your own data
# (2) Describe the two quantitative variables in the data set you obtained for HW 1.
# Choose one to be the response variable (Y), and one to be the predictor variable (X).
# Explain your choice. Do you think these variables might be related? Why or why not?
# Read csv file of my data
data.df = read.csv("data.csv")
#--------------------------------------------------------------------------------------------------
# C7. (1) Produce a publication-quality scatterplot with your
# response-variable on the y-axis and your...
# first set up the plotting window.
# mfrow creates a 1x1 window
# mar sets the margin sizes (bottom, left, top, right)
# mgp sets the axis (scale, ticks, line)
# las orients the axis scale (here we set it to horizontal)
par(mfrow=c(1,1),mar=c(3.75,3.75,0.5,0.5),mgp=c(2.75,0.5,0),las=1)
# now we create the scatterplot. xlab gives the label for the x-axis,
# ylab the label for the y-axis. Make sure to update these with your own
# variables. pch gives the point type (16=solid points)
# see ?points for options. col gives the color for the points (?colors)
?points
plot(data.df$YTD.Change,
data.df$Net.worth,
xlab="YTD Change in Net-worth (in Billions of $)",
ylab="Net worth of Individual (in Billions of $)",
pch=16,
col="blue")
###################################################################################################
#C1.
#Submitted R Script.
#--------------------------------------------------------------------------------------------------
# C6.
# Part 2: Linear regression on your own data
# (2) Describe the two quantitative variables in the data set you obtained for HW 1.
# Choose one to be the response variable (Y), and one to be the predictor variable (X).
# Explain your choice. Do you think these variables might be related? Why or why not?
# Read csv file of my data
data.df = read.csv("data.csv")
#--------------------------------------------------------------------------------------------------
# C7. (1) Produce a publication-quality scatterplot with your
# response-variable on the y-axis and your...
# first set up the plotting window.
# mfrow creates a 1x1 window
# mar sets the margin sizes (bottom, left, top, right)
# mgp sets the axis (scale, ticks, line)
# las orients the axis scale (here we set it to horizontal)
par(mfrow=c(1,1),mar=c(3.75,3.75,0.5,0.5),mgp=c(2.75,0.5,0),las=1)
# now we create the scatterplot. xlab gives the label for the x-axis,
# ylab the label for the y-axis. Make sure to update these with your own
# variables. pch gives the point type (16=solid points)
# see ?points for options. col gives the color for the points (?colors)
?points
plot(data.df$YTD.Change,
data.df$Net.worth,
xlab="YTD Change in Net-worth (in Billions of $)",
ylab="Net worth of Individual (in Billions of $)",
pch=50,
col="blue")
# now we create the scatterplot. xlab gives the label for the x-axis,
# ylab the label for the y-axis. Make sure to update these with your own
# variables. pch gives the point type (16=solid points)
# see ?points for options. col gives the color for the points (?colors)
?points
plot(data.df$YTD.Change,
data.df$Net.worth,
xlab="YTD Change in Net-worth (in Billions of $)",
ylab="Net worth of Individual (in Billions of $)",
pch=10,
col="blue")
# now we create the scatterplot. xlab gives the label for the x-axis,
# ylab the label for the y-axis. Make sure to update these with your own
# variables. pch gives the point type (16=solid points)
# see ?points for options. col gives the color for the points (?colors)
?points
###################################################################################################
#C1.
#Submitted R Script.
#--------------------------------------------------------------------------------------------------
# C6.
# Part 2: Linear regression on your own data
# (2) Describe the two quantitative variables in the data set you obtained for HW 1.
# Choose one to be the response variable (Y), and one to be the predictor variable (X).
# Explain your choice. Do you think these variables might be related? Why or why not?
# Read csv file of my data
data.df = read.csv("data.csv")
#--------------------------------------------------------------------------------------------------
# C7. (1) Produce a publication-quality scatterplot with your
# response-variable on the y-axis and your...
# first set up the plotting window.
# mfrow creates a 1x1 window
# mar sets the margin sizes (bottom, left, top, right)
# mgp sets the axis (scale, ticks, line)
# las orients the axis scale (here we set it to horizontal)
par(mfrow=c(1,1),mar=c(3.75,3.75,0.5,0.5),mgp=c(2.75,0.5,0),las=1)
# now we create the scatterplot. xlab gives the label for the x-axis,
# ylab the label for the y-axis. Make sure to update these with your own
# variables. pch gives the point type (16=solid points)
# see ?points for options. col gives the color for the points (?colors)
?points
plot(data.df$YTD.Change,
data.df$Net.worth,
xlab="YTD Change in Net-worth (in Billions of $)",
ylab="Net worth of Individual (in Billions of $)",
pch=16,
col="blue")
#--------------------------------------------------------------------------------------------------
# C9 Using the cor function in R to calculate the correlation between X and Y
# substitute the name of your dataframe and the appropriate column names
cor(data.df$YTD.Change,data.df$Net.worth)
#--------------------------------------------------------------------------------------------------
# C9 Using the cor function in R to calculate the correlation between X and Y
# substitute the name of your dataframe and the appropriate column names
cor(data.df$YTD.Change,data.df$Net.worth) # =  0.1776805
#--------------------------------------------------------------------------------------------------
# C11. (1) Now we will estimate the least-squares regression line,...
# lm uses the same formula syntax that boxplot does.
# this code estimates the linear relationship between Y and X
# for the dataframe data.df. Replace with the column names for your
# Y and X variables, and your own dataset.
my.lm=lm(Net.worth~YTD.Change,data=data.df)
# the my.lm object contains a description of the linear model,
# including the estimated coefficients. To retrieve the coefficients:
my.lm$coefficients
summary(my.lm)
###################################################################################################
#C1.
#Submitted R Script.
#--------------------------------------------------------------------------------------------------
# C6.
# Part 2: Linear regression on your own data
# (2) Describe the two quantitative variables in the data set you obtained for HW 1.
# Choose one to be the response variable (Y), and one to be the predictor variable (X).
# Explain your choice. Do you think these variables might be related? Why or why not?
# Read csv file of my data
data.df = read.csv("data.csv")
#--------------------------------------------------------------------------------------------------
# C7. (1) Produce a publication-quality scatterplot with your
# response-variable on the y-axis and your...
# first set up the plotting window.
# mfrow creates a 1x1 window
# mar sets the margin sizes (bottom, left, top, right)
# mgp sets the axis (scale, ticks, line)
# las orients the axis scale (here we set it to horizontal)
par(mfrow=c(1,1),mar=c(3.75,3.75,0.5,0.5),mgp=c(2.75,0.5,0),las=1)
# now we create the scatterplot. xlab gives the label for the x-axis,
# ylab the label for the y-axis. Make sure to update these with your own
# variables. pch gives the point type (16=solid points)
# see ?points for options. col gives the color for the points (?colors)
?points
plot(data.df$YTD.Change,
data.df$Net.worth,
xlab="YTD Change in Net-worth (in Billions of $)",
ylab="Net worth of Individual (in Billions of $)",
pch=16,
col="blue")
#--------------------------------------------------------------------------------------------------
# C9 Using the cor function in R to calculate the correlation between X and Y
# substitute the name of your dataframe and the appropriate column names
cor(data.df$YTD.Change,data.df$Net.worth) # =  0.1776805
#--------------------------------------------------------------------------------------------------
# C11. (1) Now we will estimate the least-squares regression line,...
# lm uses the same formula syntax that boxplot does.
# this code estimates the linear relationship between Y and X
# for the dataframe data.df. Replace with the column names for your
# Y and X variables, and your own dataset.
my.lm=lm(Net.worth~YTD.Change,data=data.df)
# the my.lm object contains a description of the linear model,
# including the estimated coefficients. To retrieve the coefficients:
my.lm$coefficients
summary(my.lm)
